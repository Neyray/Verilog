**实验任务1，2**

目的：设计一个电路，将拨码开关输入的4位二进制数与预设的4位二进制数（1010）进行比较，正确将点亮一位第15号led灯或逐个点亮第#15—>#0号led灯。通过编制这个最简单的游戏电路，让学生逐步熟悉和掌握Vivado的工程建立、Verilog的常用建模方法、Vivado功能仿真和NEXYS4\_100t电路板调试过程。最终可以独立编制和调试一个简单的硬件电路。



测试文件：

`timescale 1ns / 1ps



module test\_tb();



&nbsp;   reg clk, rstn;

&nbsp;   reg \[15:0] sw\_i;

&nbsp;   wire \[15:0] led\_o;

&nbsp;   integer foutput, counter;

&nbsp;   

&nbsp;   // 实例化待测模块

&nbsp;   compare\_game u\_test(

&nbsp;       .clk(clk),

&nbsp;       .rstn(rstn),

&nbsp;       .CPU\_RESETN(rstn),

&nbsp;       .BTNC(1'b0),

&nbsp;       .BTNU(1'b0),

&nbsp;       .BTNL(1'b0),

&nbsp;       .BTNR(1'b0),

&nbsp;       .BTND(1'b0),

&nbsp;       .sw\_i(sw\_i),

&nbsp;       .led\_o(led\_o),

&nbsp;       .disp\_seg\_o(),

&nbsp;       .disp\_an\_o()

&nbsp;   );

&nbsp;   

&nbsp;   // 初始化

&nbsp;   initial begin

&nbsp;       counter = 0;

&nbsp;       clk = 0;      // 从0开始

&nbsp;       rstn = 0;     // 开始复位

&nbsp;       sw\_i = 16'h000A;  // 输入1010（十六进制A）

&nbsp;       foutput = $fopen("results.txt");

&nbsp;       

&nbsp;       // 复位20ns

&nbsp;       #20;

&nbsp;       rstn = 1;     // 释放复位

&nbsp;       

&nbsp;       $display("Start testing...");

&nbsp;   end

&nbsp;   

&nbsp;   // 时钟生成：每5ns翻转一次，周期=10ns

&nbsp;   always #5 clk = ~clk;

&nbsp;   

&nbsp;   // 监控

&nbsp;   always @(posedge clk) begin

&nbsp;       $fdisplay(foutput, "led\_o:\\t %b", led\_o);

&nbsp;       $display("led\_o:\\t %b", led\_o);

&nbsp;       $display("counter: %h", counter);

&nbsp;       counter = counter + 1;

&nbsp;       

&nbsp;       if (counter > 100) begin

&nbsp;           $fclose(foutput);

&nbsp;           $stop;

&nbsp;       end

&nbsp;   end



endmodule



实现文件：

module compare\_game(

&nbsp;   input clk,

&nbsp;   input rstn,

&nbsp;   input CPU\_RESETN,

&nbsp;   input BTNC,

&nbsp;   input BTNU,

&nbsp;   input BTNL,

&nbsp;   input BTNR,

&nbsp;   input BTND,

&nbsp;   input \[15:0] sw\_i,

&nbsp;   output reg \[15:0] led\_o,

&nbsp;   output \[7:0] disp\_seg\_o,

&nbsp;   output \[7:0] disp\_an\_o

);



&nbsp;   // 目标数字

&nbsp;   parameter TARGET = 4'b1010;

&nbsp;   

&nbsp;   // 比较结果

&nbsp;   wire match;

&nbsp;   assign match = (sw\_i\[3:0] == TARGET);

&nbsp;   

&nbsp;   // 流水灯控制

&nbsp;   reg \[3:0] led\_cnt;

&nbsp;   reg \[24:0] div\_cnt;

&nbsp;   

&nbsp;   // 分频器产生tick信号

&nbsp;   always @(posedge clk or negedge rstn) begin

&nbsp;       if (!rstn) begin

&nbsp;           div\_cnt <= 25'd0;

&nbsp;       end else begin

&nbsp;           if (div\_cnt >= 25'd1\_000\_000)  // 仿真时用较小值

&nbsp;               div\_cnt <= 25'd0;

&nbsp;           else

&nbsp;               div\_cnt <= div\_cnt + 1'b1;

&nbsp;       end

&nbsp;   end

&nbsp;   

&nbsp;   wire tick = (div\_cnt == 25'd1\_000\_000);

&nbsp;   

&nbsp;   // LED控制逻辑

&nbsp;   always @(posedge clk or negedge rstn) begin

&nbsp;       if (!rstn) begin

&nbsp;           led\_o <= 16'b0000\_0000\_0000\_0000;

&nbsp;           led\_cnt <= 4'd0;

&nbsp;       end else begin

&nbsp;           if (match) begin

&nbsp;               // 匹配成功：只点亮led\_o\[15]

&nbsp;               led\_o <= 16'b1000\_0000\_0000\_0000;

&nbsp;               led\_cnt <= 4'd0;

&nbsp;           end else begin

&nbsp;               // 不匹配：流水灯效果

&nbsp;               if (tick) begin

&nbsp;                   if (led\_cnt <= 4'd15) begin

&nbsp;                       led\_o\[15 - led\_cnt] <= 1'b1;

&nbsp;                       led\_cnt <= led\_cnt + 1'b1;

&nbsp;                   end else begin

&nbsp;                       // 重新开始

&nbsp;                       led\_o <= 16'b0000\_0000\_0000\_0000;

&nbsp;                       led\_cnt <= 4'd0;

&nbsp;                   end

&nbsp;               end

&nbsp;           end

&nbsp;       end

&nbsp;   end

&nbsp;   

&nbsp;   // 数码管关闭

&nbsp;   assign disp\_seg\_o = 8'b11111111;

&nbsp;   assign disp\_an\_o = 8'b11111111;



endmodule





**实验任务3---新建一个工程seg7\_top,并新建一个seg7\_top.v顶层模块，在seg7\_top.v模块中，例化上述seg7x16.v模块程序，并传送一组数值31’b0111\_0110\_0101\_0100\_0011\_0010\_0001\_0000给该子模块，下板在数码管上显示给定的8个16进制数字。**

seg7x16:

module seg7x16(

&nbsp;   input clk,          // 系统主时钟 (通常为 50MHz 或 100MHz)

&nbsp;   input rstn,         // 异步低电平复位信号 (低电平有效)

&nbsp;   input disp\_mode,    // 显示模式选择信号 (0: 译码模式, 1: 穿透模式/直接显示)

&nbsp;   input \[63:0] i\_data, // 待显示的 64 位数据 (8 个 8 位数码管数据)

&nbsp;   output \[7:0] o\_seg, // 7段数码管的段选线输出 (a, b, c, d, e, f, g, dp)

&nbsp;   output \[7:0] o\_sel  // 8位共阴/共阳数码管的位选线输出 (激活哪个数码管)

&nbsp;   );



&nbsp;   // --- 1) 扫描时钟分频 ---

&nbsp;   reg \[14:0] cnt;    // 分频计数器

&nbsp;   wire seg7\_clk;     // 数码管扫描时钟 (低频，通常几百 Hz 到几 kHz)

&nbsp;   

&nbsp;   // 时序逻辑：分频计数

&nbsp;   always @(posedge clk, negedge rstn) begin

&nbsp;       if (!rstn)

&nbsp;           cnt <= 0;

&nbsp;       else

&nbsp;           cnt <= cnt + 1'b1;

&nbsp;   end

&nbsp;   

&nbsp;   // 输出扫描时钟：使用计数器的第 14 位，实现 clk / 2^15 的分频

&nbsp;   assign seg7\_clk = cnt\[14]; 



&nbsp;   // --- 2) 数码管位选地址生成 (8选1) ---

&nbsp;   reg \[2:0] seg7\_addr; // 当前被选中的数码管地址 (0 到 7)

&nbsp;   

&nbsp;   // 时序逻辑：在扫描时钟 seg7\_clk 的上升沿递增地址

&nbsp;   always @(posedge seg7\_clk, negedge rstn) begin

&nbsp;       if(!rstn)

&nbsp;           seg7\_addr <= 0;

&nbsp;       else

&nbsp;           seg7\_addr <= seg7\_addr + 1'b1;

&nbsp;   end

&nbsp;     

&nbsp;   // --- 3) 位选信号生成 (o\_sel) ---

&nbsp;   reg \[7:0] o\_sel\_r; // 位选信号的寄存器版本

&nbsp;   

&nbsp;   // 组合逻辑：根据当前地址 seg7\_addr 确定哪个数码管被使能 (一位有效)

&nbsp;   always @(\*) begin

&nbsp;       case (seg7\_addr)

&nbsp;           7 : o\_sel\_r = 8'b01111111; // 选中第 7 位 (最高位)

&nbsp;           6 : o\_sel\_r = 8'b10111111;

&nbsp;           5 : o\_sel\_r = 8'b11011111;

&nbsp;           4 : o\_sel\_r = 8'b11101111;

&nbsp;           3 : o\_sel\_r = 8'b11110111;

&nbsp;           2 : o\_sel\_r = 8'b11111011;

&nbsp;           1 : o\_sel\_r = 8'b11111101;

&nbsp;           0 : o\_sel\_r = 8'b11111110; // 选中第 0 位 (最低位)

&nbsp;       endcase

&nbsp;   end

&nbsp;   

&nbsp;   // --- 4) 数据选择逻辑 (根据地址选择当前数码管的数据) ---

&nbsp;   reg \[63:0] i\_data\_store; // 将输入数据 i\_data 寄存器化存储

&nbsp;   

&nbsp;   // 时序逻辑：在主时钟 clk 上锁存输入数据 i\_data

&nbsp;   always @(posedge clk, negedge rstn ) begin

&nbsp;       if(!rstn)

&nbsp;           i\_data\_store <= 0;

&nbsp;       else

&nbsp;           i\_data\_store <= i\_data;

&nbsp;   end



&nbsp;   reg \[7:0] seg\_data\_r; // 当前数码管要显示的 8 位数据 (来自 i\_data\_store)

&nbsp;   

&nbsp;   // 组合逻辑：根据 disp\_mode 和 seg7\_addr 选择数据

&nbsp;   always @(\*) begin

&nbsp;       if(disp\_mode==1'b0)begin // Hex 译码模式 (通常只看 32 位数据，每位 4 bits)

&nbsp;           case(seg7\_addr)

&nbsp;               // 从 i\_data\_store 的低 32 位中提取 4 bits 数据 (高 4 位为 0)

&nbsp;               0 : seg\_data\_r = i\_data\_store\[3:0];

&nbsp;               1 : seg\_data\_r = i\_data\_store\[7:4];

&nbsp;               2 : seg\_data\_r = i\_data\_store\[11:8];

&nbsp;               3 : seg\_data\_r = i\_data\_store\[15:12];

&nbsp;               4 : seg\_data\_r = i\_data\_store\[19:16];

&nbsp;               5 : seg\_data\_r = i\_data\_store\[23:20];

&nbsp;               6 : seg\_data\_r = i\_data\_store\[27:24];

&nbsp;               7 : seg\_data\_r = i\_data\_store\[31:28];

&nbsp;           endcase end

&nbsp;       else begin // 穿透/跑马灯模式 (使用 64 位数据，每位 8 bits)

&nbsp;           case(seg7\_addr)

&nbsp;               // 从 i\_data\_store 的 64 位中提取 8 bits 数据

&nbsp;               0 : seg\_data\_r = i\_data\_store\[7:0];

&nbsp;               1 : seg\_data\_r = i\_data\_store\[15:8];

&nbsp;               2 : seg\_data\_r = i\_data\_store\[23:16];

&nbsp;               3 : seg\_data\_r = i\_data\_store\[31:24];

&nbsp;               4 : seg\_data\_r = i\_data\_store\[39:32];

&nbsp;               5 : seg\_data\_r = i\_data\_store\[47:40];

&nbsp;               6 : seg\_data\_r = i\_data\_store\[55:48];

&nbsp;               7 : seg\_data\_r = i\_data\_store\[63:56];

&nbsp;           endcase end

&nbsp;   end

&nbsp;   

&nbsp;   // --- 5) 7段码译码或直接输出 ---

&nbsp;   reg \[7:0] o\_seg\_r; // 段选信号的寄存器版本

&nbsp;   

&nbsp;   // 时序逻辑：进行 Hex 译码并寄存器化输出

&nbsp;   always @(posedge clk, negedge rstn) begin

&nbsp;       if(!rstn)

&nbsp;           o\_seg\_r <= 8'hff; // 复位时全灭

&nbsp;       else if(disp\_mode==1'b0)begin // Hex 译码模式

&nbsp;           // 将 seg\_data\_r 的低 4 位（0-F）译码成 7 段码

&nbsp;           case(seg\_data\_r\[3:0]) // 注意这里使用了 seg\_data\_r\[3:0]

&nbsp;               4'h0 : o\_seg\_r <= 8'hC0;

&nbsp;               4'h1 : o\_seg\_r <= 8'hF9;

&nbsp;               4'h2 : o\_seg\_r <= 8'hA4;

&nbsp;               4'h3 : o\_seg\_r <= 8'hB0;

&nbsp;               4'h4 : o\_seg\_r <= 8'h99;

&nbsp;               4'h5 : o\_seg\_r <= 8'h92;

&nbsp;               4'h6 : o\_seg\_r <= 8'h82;

&nbsp;               4'h7 : o\_seg\_r <= 8'hF8;

&nbsp;               4'h8 : o\_seg\_r <= 8'h80;

&nbsp;               4'h9 : o\_seg\_r <= 8'h90;

&nbsp;               4'hA : o\_seg\_r <= 8'h88;

&nbsp;               4'hB : o\_seg\_r <= 8'h83;

&nbsp;               4'hC : o\_seg\_r <= 8'hC6;

&nbsp;               4'hD : o\_seg\_r <= 8'hA1;

&nbsp;               4'hE : o\_seg\_r <= 8'h86;

&nbsp;               4'hF : o\_seg\_r <= 8'h8E;

&nbsp;               default :o\_seg\_r<=8'hFF; 

&nbsp;           endcase end

&nbsp;       else begin 

&nbsp;          

&nbsp;           o\_seg\_r<=seg\_data\_r;

&nbsp;       end

&nbsp;   end

&nbsp;  

&nbsp;   assign o\_sel = o\_sel\_r;

&nbsp;   assign o\_seg = o\_seg\_r;



endmodule



display文件：

module work3(clk,rstn,sw\_i,disp\_seg\_o,disp\_an\_o);

&nbsp;   input clk;

&nbsp;   input rstn;

&nbsp;   input\[15:0]sw\_i;

&nbsp;   output\[7:0]disp\_an\_o,disp\_seg\_o;

&nbsp;   



reg \[31:0] clkdiv;

wire Clk\_CPU;



always@(posedge clk or negedge rstn) begin

&nbsp;   if(!rstn)

&nbsp;      clkdiv<=0;

&nbsp;   else clkdiv<=clkdiv+1'b1;

&nbsp;   end

assign Clk\_CPU=(sw\_i\[15])?clkdiv\[27]:clkdiv\[25];



reg \[63:0]display\_data;

reg \[5:0]led\_data\_addr;

reg \[63:0]led\_disp\_data;

parameter LED\_DATA\_NUM = 19;



reg \[63:0]LED\_DATA\[18:0];

&nbsp;initial begin

&nbsp;   LED\_DATA\[0]=64'hC6F6F6F0C6F6F6F0;

&nbsp;   LED\_DATA\[1] =64'hF9F6F6CFF9F6F6CF;

&nbsp;   LED\_DATA\[2]=64'hFFC6F0FFFFC6F0FF;

&nbsp;   LED\_DATA\[3]=64'hFFC0FFFFFFC0FFFF;

&nbsp;   LED\_DATA\[4]=64'hFFA3FFFFFFA3FFFF;

&nbsp;   LED\_DATA\[5]=64'hFFFFA3FFFFFFA3FF;

&nbsp;   LED\_DATA\[6]=64'hFFFF9CFFFFFF9CFF;

&nbsp;   LED\_DATA\[7]=64'hFF9EBCFFFF9EBCFF;

&nbsp;   LED\_DATA\[8]=64'hFF9CFFFFFF9CFFFF;

&nbsp;   LED\_DATA\[9]=64'hFFC0FFFFFFC0FFFF;

&nbsp;   LED\_DATA\[10]=64'hFFA3FFFFFFA3FFFF;

&nbsp;   LED\_DATA\[11]=64'hFFA7B3FFFFA7B3FF;

&nbsp;   LED\_DATA\[12]=64'hFFC6F0FFFFC6F0FF;

&nbsp;   LED\_DATA\[13]=64'hF9F6F6CFF9F6F6CF;

&nbsp;   LED\_DATA\[14]=64'h9EBEBEBC9EBEBEBC;

&nbsp;   LED\_DATA\[15]=64'h2737373327373733;

&nbsp;   LED\_DATA\[16]=64'h505454EC505454EC;

&nbsp;   LED\_DATA\[17]=64'h744454F8744454F8;

&nbsp;   LED\_DATA\[18]=64'h0062080000620800;

&nbsp;end

&nbsp;

always@(posedge Clk\_CPU or negedge rstn) begin

&nbsp;   if(!rstn) begin led\_data\_addr = 6'd0 ;led\_disp\_data = 64'b1;end

&nbsp;   else if(sw\_i\[0]==1'b1) begin

&nbsp;       if (led\_data\_addr == LED\_DATA\_NUM) begin led\_data\_addr =6'd0;led\_disp\_data = 64'b1;end

&nbsp;       led\_disp\_data = LED\_DATA\[led\_data\_addr];

&nbsp;       led\_data\_addr = led\_data\_addr + 1'b1; end

&nbsp;     else  led\_data\_addr = led\_data\_addr ;

end



wire \[31:0]instr;

reg\[31:0]reg\_data;

reg\[31:0]alu\_disp\_data;

reg\[31:0]dmem\_data;



always @(sw\_i) begin

&nbsp;   if (sw\_i\[0]==0) begin

&nbsp;   case (sw\_i\[14:11])

&nbsp;       4'b1000:display\_data =instr;

&nbsp;       4'b0100:display\_data = reg\_data;

&nbsp;       4'b0010:display\_data = alu\_disp\_data;

&nbsp;       4'b0001:display\_data= dmem\_data;

&nbsp;       default: display\_data=instr;

&nbsp;   endcase end

else begin display\_data = led\_disp\_data;end

end





seg7x16 u\_seg7x16(

.clk(clk),

.rstn (rstn),

.i\_data(display\_data),

.disp\_mode(sw\_i\[0]),

.o\_seg(disp\_seg\_o),

.o\_sel(disp\_an\_o)

);



endmodule



**实验任务4---ROM模块**

rom就是你定义一个虚拟模块，vivado自动帮你生成它的模块内部代码，然后你只需要导入一个数据文件进去，就可以直接使用这个虚拟模块读取，然后你在外面套那个数码管的代码，把跑马灯的那些数据换成从虚拟模块读取，就能显示rom内容了



seg7x16文件：

//`timescale 1ns / 1ps

module seg7x16(

&nbsp;   input clk,

&nbsp;   input rstn,

&nbsp;   input \[31:0] i\_data,

&nbsp;   output \[7:0] o\_seg,

&nbsp;   output \[7:0] o\_sel

);



&nbsp;   // 1) 分频 - 利用计数器cnt对clk分频得到seg7\_clk

&nbsp;   reg \[14:0] cnt;

&nbsp;   wire seg7\_clk;

&nbsp;   

&nbsp;   always @(posedge clk, negedge rstn)

&nbsp;       if (!rstn)

&nbsp;           cnt <= 0;

&nbsp;       else

&nbsp;           cnt <= cnt + 1'b1;

&nbsp;   

&nbsp;   assign seg7\_clk = cnt\[14];



&nbsp;   // 2) 8选1 - seg7\_addr作为8选1选择器的地址信号

&nbsp;   reg \[2:0] seg7\_addr;

&nbsp;   

&nbsp;   always @(posedge seg7\_clk, negedge rstn)

&nbsp;       if (!rstn)

&nbsp;           seg7\_addr <= 0;

&nbsp;       else

&nbsp;           seg7\_addr <= seg7\_addr + 1'b1;



&nbsp;   // 3) 输出选中数码管使能信号

&nbsp;   reg \[7:0] o\_sel\_r;

&nbsp;   

&nbsp;   always @(\*) 

&nbsp;       case(seg7\_addr)

&nbsp;           3'd7: o\_sel\_r = 8'b01111111;

&nbsp;           3'd6: o\_sel\_r = 8'b10111111;

&nbsp;           3'd5: o\_sel\_r = 8'b11011111;

&nbsp;           3'd4: o\_sel\_r = 8'b11101111;

&nbsp;           3'd3: o\_sel\_r = 8'b11110111;

&nbsp;           3'd2: o\_sel\_r = 8'b11111011;

&nbsp;           3'd1: o\_sel\_r = 8'b11111101;

&nbsp;           3'd0: o\_sel\_r = 8'b11111110;

&nbsp;       endcase



&nbsp;   // 4) 8个数码管显示数字串 - 存储输入数据

&nbsp;   reg \[31:0] i\_data\_store;

&nbsp;   

&nbsp;   always @(posedge clk, negedge rstn)

&nbsp;       if (!rstn)

&nbsp;           i\_data\_store <= 0;

&nbsp;       else

&nbsp;           i\_data\_store <= i\_data;



&nbsp;   // 当前一个数码管要显示的数串

&nbsp;   reg \[3:0] seg\_data\_r;

&nbsp;   

&nbsp;   always @(\*)

&nbsp;       case(seg7\_addr)

&nbsp;           3'd0: seg\_data\_r = i\_data\_store\[3:0];

&nbsp;           3'd1: seg\_data\_r = i\_data\_store\[7:4];

&nbsp;           3'd2: seg\_data\_r = i\_data\_store\[11:8];

&nbsp;           3'd3: seg\_data\_r = i\_data\_store\[15:12];

&nbsp;           3'd4: seg\_data\_r = i\_data\_store\[19:16];

&nbsp;           3'd5: seg\_data\_r = i\_data\_store\[23:20];

&nbsp;           3'd6: seg\_data\_r = i\_data\_store\[27:24];

&nbsp;           3'd7: seg\_data\_r = i\_data\_store\[31:28];

&nbsp;       endcase



&nbsp;   // 5) 要显示数字的7段码

&nbsp;   reg \[7:0] o\_seg\_r;

&nbsp;   

&nbsp;   always @(posedge clk, negedge rstn)

&nbsp;       if (!rstn)

&nbsp;           o\_seg\_r <= 8'hff;

&nbsp;       else

&nbsp;           case(seg\_data\_r)

&nbsp;               4'h0: o\_seg\_r <= 8'hC0;

&nbsp;               4'h1: o\_seg\_r <= 8'hF9;

&nbsp;               4'h2: o\_seg\_r <= 8'hA4;

&nbsp;               4'h3: o\_seg\_r <= 8'hB0;

&nbsp;               4'h4: o\_seg\_r <= 8'h99;

&nbsp;               4'h5: o\_seg\_r <= 8'h92;

&nbsp;               4'h6: o\_seg\_r <= 8'h82;

&nbsp;               4'h7: o\_seg\_r <= 8'hF8;

&nbsp;               4'h8: o\_seg\_r <= 8'h80;

&nbsp;               4'h9: o\_seg\_r <= 8'h90;

&nbsp;               4'hA: o\_seg\_r <= 8'h88;

&nbsp;               4'hB: o\_seg\_r <= 8'h83;

&nbsp;               4'hC: o\_seg\_r <= 8'hC6;

&nbsp;               4'hD: o\_seg\_r <= 8'hA1;

&nbsp;               4'hE: o\_seg\_r <= 8'h86;

&nbsp;               4'hF: o\_seg\_r <= 8'h8E;

&nbsp;           endcase



&nbsp;   assign o\_sel = o\_sel\_r;

&nbsp;   assign o\_seg = o\_seg\_r;



endmodule



sccomp文件：



module sccomp(clk, rstn, sw\_i, disp\_seg\_o, disp\_an\_o);

&nbsp;   input clk;

&nbsp;   input rstn;

&nbsp;   input \[15:0] sw\_i;

&nbsp;   output \[7:0] disp\_an\_o, disp\_seg\_o;

&nbsp;   

&nbsp;   reg \[31:0] clkdiv;

&nbsp;   wire clk\_CPU;

&nbsp;   

&nbsp;   // 时钟分频

&nbsp;   always @(posedge clk or negedge rstn) begin

&nbsp;       if (!rstn) 

&nbsp;           clkdiv <= 0;

&nbsp;       else 

&nbsp;           clkdiv <= clkdiv + 1'b1;

&nbsp;   end

&nbsp;   

&nbsp;   assign clk\_CPU = (sw\_i\[15]) ? clkdiv\[27] : clkdiv\[25];

&nbsp;   

&nbsp;   // 7段数码管显示相关

&nbsp;   reg \[63:0] display\_data;

&nbsp;   reg \[5:0] led\_data\_addr;

&nbsp;   reg \[63:0] led\_disp\_data;

&nbsp;   wire \[63:0] rom\_data\_out;

&nbsp;   

&nbsp;   parameter LED\_DATA\_NUM = 19;

&nbsp;   

&nbsp;   // ROM IP核实例化 - 方案1: 纯组合逻辑ROM

&nbsp;   dist\_mem\_gen\_0 u\_led\_rom (

&nbsp;       .a(led\_data\_addr\[4:0]),     // 地址输入，5位(0-18)

&nbsp;       .spo(rom\_data\_out)           // 数据输出 64位

&nbsp;   );

&nbsp;   

&nbsp;   // 产生LED\_DATA地址和数据

&nbsp;   always @(posedge clk\_CPU or negedge rstn) begin

&nbsp;       if (!rstn) begin

&nbsp;           led\_data\_addr <= 6'd0;

&nbsp;           led\_disp\_data <= 64'b1;

&nbsp;       end

&nbsp;       else if (sw\_i\[0] == 1'b1) begin

&nbsp;           if (led\_data\_addr == LED\_DATA\_NUM) begin

&nbsp;               led\_data\_addr <= 6'd0;

&nbsp;           end

&nbsp;           else begin

&nbsp;               led\_data\_addr <= led\_data\_addr + 1'b1;

&nbsp;           end

&nbsp;           led\_disp\_data <= rom\_data\_out;

&nbsp;       end

&nbsp;       else begin

&nbsp;           led\_data\_addr <= led\_data\_addr;

&nbsp;           led\_disp\_data <= led\_disp\_data;

&nbsp;       end

&nbsp;   end

&nbsp;   

&nbsp;   // 其他信号声明

&nbsp;   wire \[31:0] instr;

&nbsp;   reg \[31:0] reg\_data;

&nbsp;   reg \[31:0] alu\_disp\_data;

&nbsp;   reg \[31:0] demem\_data;

&nbsp;   

&nbsp;   // 为未使用的信号赋默认值

&nbsp;   assign instr = 32'h00000000;

&nbsp;   

&nbsp;   always @(posedge clk\_CPU or negedge rstn) begin

&nbsp;       if (!rstn) begin

&nbsp;           reg\_data <= 32'h0;

&nbsp;           alu\_disp\_data <= 32'h0;

&nbsp;           demem\_data <= 32'h0;

&nbsp;       end

&nbsp;       else begin

&nbsp;           reg\_data <= 32'h0;

&nbsp;           alu\_disp\_data <= 32'h0;

&nbsp;           demem\_data <= 32'h0;

&nbsp;       end

&nbsp;   end

&nbsp;   

&nbsp;   // 选择显示源数据

&nbsp;   always @(\*) begin

&nbsp;       if (sw\_i\[0] == 0) begin

&nbsp;           case (sw\_i\[14:11])

&nbsp;               4'b1000: display\_data = {32'h0, instr};

&nbsp;               4'b0100: display\_data = {32'h0, reg\_data};

&nbsp;               4'b0010: display\_data = {32'h0, alu\_disp\_data};

&nbsp;               4'b0001: display\_data = {32'h0, demem\_data};

&nbsp;               default: display\_data = {32'h0, instr};

&nbsp;           endcase

&nbsp;       end

&nbsp;       else begin

&nbsp;           display\_data = led\_disp\_data;

&nbsp;       end

&nbsp;   end

&nbsp;   

&nbsp;   // 7段数码管显示模块实例化

&nbsp;   seg7x16 u\_seg7x16(

&nbsp;       .clk(clk),

&nbsp;       .rstn(rstn),

&nbsp;       .i\_data(display\_data\[31:0]),

&nbsp;       .o\_seg(disp\_seg\_o),

&nbsp;       .o\_sel(disp\_an\_o)

&nbsp;   );



endmodule



**实验任务5---RF与ALU连接的实验（将三个实验整合，RF,ALU , 二者连接）**

**RF:**

**实验目的：**

**1、使用verilog语言设计并实现一个RegisterFile。它由32×32位的寄存器堆（即含有32个寄存器，每个寄存器32位，其中#0寄存器永远为零。**

**2、初步了解使用Fpga实现RF设计的全过程，熟识vivado软件基本功能的使用。**



**原理概念：寄存器文件（register file）又称寄存器堆，是 CPU 中多个寄存器组成的阵列，通常由快速的静态随机读写存储器（SRAM）实现。这种 RAM 具有专门的读端口与写端口，可以多路并发访问不同的寄存器。**



**ALU:**

**实验目的：** 

**1.根据ALU原理框图，使用verilog语言设计并实现一个32位的ALU模块，运算指令码长度\[4:0]；**

**2.一个32位数输入到A口，或由sw10-sw7输入4位数到A口；**

**3.一个32位数输入到B口，或由SW6-SW3输入4位数到B口**

**4.运算器暂只支持”加、减 “2种操作，输入控制信号ALUOp（\[4:0]）；**

**5.结果输出到C\[31:0]；**

**由sw\[12]控制数码管显示A，B，C，Zero四个数。**



**实验任务二：**  

**1）实现RF部件和ALU部件的关联，使得指定寄存器的数值送入ALU部件参与运算**

**2）通过SW\_i输入双端口要读出的寄存器编号A1，A2，并将读出的数值RD1，RD2送入ALU的A，B输入端，根据设定的ALUOp，计算结果，并显示。**

**3）通过SW\_i输入要写入寄存器编号和数值A3，WD，再通过步骤2），将计算结果显示出来。**



RF\_ALU\_top：





//=====================================================

// ALU Module Definition

//=====================================================

`define ALUOp\_add 5'b00001

`define ALUOp\_sub 5'b00010



module alu(

&nbsp;   input signed \[31:0] A, B,      // ALU input numbers

&nbsp;   input \[4:0] ALUOp,              // ALU operation code

&nbsp;   output signed \[31:0] C,         // ALU result

&nbsp;   output reg \[7:0] Zero           // Zero flag

);

&nbsp;   reg signed \[31:0] C\_r;

&nbsp;   

&nbsp;   always @(\*) begin

&nbsp;       case(ALUOp)

&nbsp;           `ALUOp\_add: C\_r = A + B;

&nbsp;           `ALUOp\_sub: C\_r = A - B;

&nbsp;           default: C\_r = 32'h0;

&nbsp;       endcase

&nbsp;       

&nbsp;       // Zero flag: Zero\[0] indicates if result is zero

&nbsp;       if(C\_r == 32'h0)

&nbsp;           Zero = 8'h01;

&nbsp;       else

&nbsp;           Zero = 8'h00;

&nbsp;   end

&nbsp;   

&nbsp;   assign C = C\_r;

endmodule



//=====================================================

// Register File Module Definition  

//=====================================================

module RF(

&nbsp;   input clk,                      // 100MHz clock

&nbsp;   input rst,                      // Reset signal

&nbsp;   input RFWr,                     // Register write enable

&nbsp;   input \[15:0] sw\_i,              // Switch input

&nbsp;   input \[4:0] A1, A2, A3,         // Register numbers

&nbsp;   input \[31:0] WD,                // Write data

&nbsp;   output reg \[31:0] RD1, RD2      // Read data outputs

);

&nbsp;   reg \[31:0] rf\[31:0];            // 32 registers, each 32 bits

&nbsp;   integer i;

&nbsp;   

&nbsp;   // Initialize registers

&nbsp;   initial begin

&nbsp;       for(i = 0; i < 32; i = i + 1)

&nbsp;           rf\[i] = i;              // Initialize rf\[i] = i

&nbsp;   end

&nbsp;   

&nbsp;   // Write operation

&nbsp;   always @(posedge clk or posedge rst) begin

&nbsp;       if(rst) begin

&nbsp;           for(i = 0; i < 32; i = i + 1)

&nbsp;               rf\[i] <= i;

&nbsp;       end

&nbsp;       else begin

&nbsp;           if(RFWr \&\& sw\_i\[1] == 0 \&\& A3 != 0) begin  // sw\[1]=0: normal mode, can modify

&nbsp;               rf\[A3] <= WD;

&nbsp;           end

&nbsp;       end

&nbsp;       rf\[0] <= 32'h0;  // rf\[0] always 0

&nbsp;   end

&nbsp;   

&nbsp;   // Read operation (combinational)

&nbsp;   always @(\*) begin

&nbsp;       RD1 = rf\[A1];

&nbsp;       RD2 = rf\[A2];

&nbsp;   end

endmodule



//=====================================================

// Top Module - RF and ALU Integration

//=====================================================

module top(

&nbsp;   input clk,

&nbsp;   input rstn,

&nbsp;   input \[15:0] sw\_i,

&nbsp;   input CPU\_RESETN,

&nbsp;   input BTNC, BTNU, BTNL, BTNR, BTND,

&nbsp;   output \[7:0] disp\_seg\_o,

&nbsp;   output \[7:0] disp\_an\_o,

&nbsp;   output \[15:0] led\_o

);

&nbsp;   // Clock divider for display

&nbsp;   reg \[31:0] clkdiv;

&nbsp;   wire Clk\_CPU;

&nbsp;   

&nbsp;   always @(posedge clk or negedge rstn) begin

&nbsp;       if(!rstn)

&nbsp;           clkdiv <= 0;

&nbsp;       else

&nbsp;           clkdiv <= clkdiv + 1'b1;

&nbsp;   end

&nbsp;   

&nbsp;   assign Clk\_CPU = (sw\_i\[15]) ? clkdiv\[27] : clkdiv\[25];

&nbsp;   

&nbsp;   //=================================================

&nbsp;   // Signal Definitions

&nbsp;   //=================================================

&nbsp;   wire \[4:0] A1, A2, A3;

&nbsp;   wire \[31:0] WD;

&nbsp;   wire \[31:0] RD1, RD2;

&nbsp;   wire RFWr;

&nbsp;   wire \[4:0] ALUOp;

&nbsp;   wire \[31:0] A\_alu, B\_alu;

&nbsp;   wire signed \[31:0] C\_alu;

&nbsp;   wire \[7:0] Zero;

&nbsp;   

&nbsp;   //=================================================

&nbsp;   // Input Signal Processing

&nbsp;   //=================================================

&nbsp;   // sw\[2]=0: Read mode

&nbsp;   //   sw\[10:8] -> A1 (read register 1)

&nbsp;   //   sw\[7:5]  -> A2 (read register 2)

&nbsp;   // sw\[2]=1: Write mode

&nbsp;   //   sw\[10:8] -> A3 (write register number)

&nbsp;   //   sw\[7:5]  -> WD (write data, sign-extended)

&nbsp;   

&nbsp;   assign RFWr = sw\_i\[2];  // sw\[2]=1: write enable

&nbsp;   

&nbsp;   // A1, A2, A3 address assignment (extend 3 bits to 5 bits)

&nbsp;   assign A1 = (sw\_i\[2] == 0) ? {2'b00, sw\_i\[10:8]} : 5'b0;

&nbsp;   assign A2 = (sw\_i\[2] == 0) ? {2'b00, sw\_i\[7:5]} : 5'b0;

&nbsp;   assign A3 = (sw\_i\[2] == 1) ? {2'b00, sw\_i\[10:8]} : 5'b0;

&nbsp;   

&nbsp;   // Write data - sign extend 3 bits to 32 bits

&nbsp;   assign WD = (sw\_i\[2] == 1) ? {{29{sw\_i\[7]}}, sw\_i\[7:5]} : 32'h0;

&nbsp;   

&nbsp;   // ALU operation control

&nbsp;   // sw\[4:3] -> ALUOp

&nbsp;   // For simplicity: sw\[3]=0 -> sub, sw\[3]=1 -> add

&nbsp;   assign ALUOp = (sw\_i\[3] == 1) ? `ALUOp\_add : `ALUOp\_sub;

&nbsp;   

&nbsp;   //=================================================

&nbsp;   // Module Instantiation

&nbsp;   //=================================================

&nbsp;   // Register File

&nbsp;   RF u\_rf(

&nbsp;       .clk(clk),

&nbsp;       .rst(~rstn),

&nbsp;       .RFWr(RFWr),

&nbsp;       .sw\_i(sw\_i),

&nbsp;       .A1(A1),

&nbsp;       .A2(A2),

&nbsp;       .A3(A3),

&nbsp;       .WD(WD),

&nbsp;       .RD1(RD1),

&nbsp;       .RD2(RD2)

&nbsp;   );

&nbsp;   

&nbsp;   // ALU inputs come from RF outputs

&nbsp;   assign A\_alu = RD1;

&nbsp;   assign B\_alu = RD2;

&nbsp;   

&nbsp;   // ALU

&nbsp;   alu u\_alu(

&nbsp;       .A(A\_alu),

&nbsp;       .B(B\_alu),

&nbsp;       .ALUOp(ALUOp),

&nbsp;       .C(C\_alu),

&nbsp;       .Zero(Zero)

&nbsp;   );

&nbsp;   

&nbsp;   //=================================================

&nbsp;   // Display Control Logic

&nbsp;   //=================================================

&nbsp;   reg \[63:0] display\_data;

&nbsp;   reg \[5:0] disp\_addr;

&nbsp;   reg \[63:0] disp\_data\_buf\[34:0];  // Buffer for cyclic display

&nbsp;   

&nbsp;   // Prepare display data based on mode

&nbsp;   always @(posedge Clk\_CPU or negedge rstn) begin

&nbsp;       if(!rstn) begin

&nbsp;           disp\_addr <= 6'd0;

&nbsp;       end

&nbsp;       else if(sw\_i\[14] == 1'b1) begin  // sw\[14]=1: Display RF contents

&nbsp;           if(disp\_addr >= 6'd33)  // 32 registers + 1 FFFFFFFF + reset

&nbsp;               disp\_addr <= 6'd0;

&nbsp;           else

&nbsp;               disp\_addr <= disp\_addr + 1'b1;

&nbsp;       end

&nbsp;       else if(sw\_i\[12] == 1'b1) begin  // sw\[12]=1: Display A,B,C,Zero

&nbsp;           if(disp\_addr >= 6'd5)  // 4 values + 1 FFFFFFFF + reset

&nbsp;               disp\_addr <= 6'd0;

&nbsp;           else

&nbsp;               disp\_addr <= disp\_addr + 1'b1;

&nbsp;       end

&nbsp;       else begin

&nbsp;           disp\_addr <= 6'd0;

&nbsp;       end

&nbsp;   end

&nbsp;   

&nbsp;   // Display data selection

&nbsp;   always @(\*) begin

&nbsp;       if(sw\_i\[14] == 1'b1) begin  // Display RF contents

&nbsp;           if(disp\_addr < 32)

&nbsp;               display\_data = u\_rf.rf\[disp\_addr];

&nbsp;           else

&nbsp;               display\_data = 64'hFFFFFFFFFFFFFFFF;

&nbsp;       end

&nbsp;       else if(sw\_i\[12] == 1'b1) begin  // Display A, B, C, Zero

&nbsp;           case(disp\_addr)

&nbsp;               6'd0: display\_data = {32'h0, A\_alu};      // A

&nbsp;               6'd1: display\_data = {32'h0, B\_alu};      // B

&nbsp;               6'd2: display\_data = {32'h0, C\_alu};      // C

&nbsp;               6'd3: display\_data = {56'h0, Zero};       // Zero

&nbsp;               default: display\_data = 64'hFFFFFFFFFFFFFFFF;

&nbsp;           endcase

&nbsp;       end

&nbsp;       else begin

&nbsp;           display\_data = {32'h0, C\_alu};  // Default: display ALU result

&nbsp;       end

&nbsp;   end

&nbsp;   

&nbsp;   // LED display - show ALU result on lower 16 LEDs

&nbsp;   assign led\_o = C\_alu\[15:0];

&nbsp;   

&nbsp;   //=================================================

&nbsp;   // 7-Segment Display Module

&nbsp;   //=================================================

&nbsp;   seg7x16 u\_seg7x16(

&nbsp;       .clk(clk),

&nbsp;       .rstn(rstn),

&nbsp;       .i\_data(display\_data),

&nbsp;       .disp\_mode(1'b0),  // Hex decode mode

&nbsp;       .o\_seg(disp\_seg\_o),

&nbsp;       .o\_sel(disp\_an\_o)

&nbsp;   );



endmodule



seg7x16:





module seg7x16(

&nbsp;   input clk,          // 系统主时钟 (通常为 50MHz 或 100MHz)

&nbsp;   input rstn,         // 异步低电平复位信号 (低电平有效)

&nbsp;   input disp\_mode,    // 显示模式选择信号 (0: 译码模式, 1: 穿透模式/直接显示)

&nbsp;   input \[63:0] i\_data, // 待显示的 64 位数据 (8 个 8 位数码管数据)

&nbsp;   output \[7:0] o\_seg, // 7段数码管的段选线输出 (a, b, c, d, e, f, g, dp)

&nbsp;   output \[7:0] o\_sel  // 8位共阴/共阳数码管的位选线输出 (激活哪个数码管)

&nbsp;   );



&nbsp;   // --- 1) 扫描时钟分频 ---

&nbsp;   reg \[14:0] cnt;    // 分频计数器

&nbsp;   wire seg7\_clk;     // 数码管扫描时钟 (低频，通常几百 Hz 到几 kHz)

&nbsp;   

&nbsp;   // 时序逻辑：分频计数

&nbsp;   always @(posedge clk, negedge rstn) begin

&nbsp;       if (!rstn)

&nbsp;           cnt <= 0;

&nbsp;       else

&nbsp;           cnt <= cnt + 1'b1;

&nbsp;   end

&nbsp;   

&nbsp;   // 输出扫描时钟：使用计数器的第 14 位，实现 clk / 2^15 的分频

&nbsp;   assign seg7\_clk = cnt\[14]; 



&nbsp;   // --- 2) 数码管位选地址生成 (8选1) ---

&nbsp;   reg \[2:0] seg7\_addr; // 当前被选中的数码管地址 (0 到 7)

&nbsp;   

&nbsp;   // 时序逻辑：在扫描时钟 seg7\_clk 的上升沿递增地址

&nbsp;   always @(posedge seg7\_clk, negedge rstn) begin

&nbsp;       if(!rstn)

&nbsp;           seg7\_addr <= 0;

&nbsp;       else

&nbsp;           seg7\_addr <= seg7\_addr + 1'b1;

&nbsp;   end

&nbsp;     

&nbsp;   // --- 3) 位选信号生成 (o\_sel) ---

&nbsp;   reg \[7:0] o\_sel\_r; // 位选信号的寄存器版本

&nbsp;   

&nbsp;   // 组合逻辑：根据当前地址 seg7\_addr 确定哪个数码管被使能 (一位有效)

&nbsp;   always @(\*) begin

&nbsp;       case (seg7\_addr)

&nbsp;           7 : o\_sel\_r = 8'b01111111; // 选中第 7 位 (最高位)

&nbsp;           6 : o\_sel\_r = 8'b10111111;

&nbsp;           5 : o\_sel\_r = 8'b11011111;

&nbsp;           4 : o\_sel\_r = 8'b11101111;

&nbsp;           3 : o\_sel\_r = 8'b11110111;

&nbsp;           2 : o\_sel\_r = 8'b11111011;

&nbsp;           1 : o\_sel\_r = 8'b11111101;

&nbsp;           0 : o\_sel\_r = 8'b11111110; // 选中第 0 位 (最低位)

&nbsp;       endcase

&nbsp;   end

&nbsp;   

&nbsp;   // --- 4) 数据选择逻辑 (根据地址选择当前数码管的数据) ---

&nbsp;   reg \[63:0] i\_data\_store; // 将输入数据 i\_data 寄存器化存储

&nbsp;   

&nbsp;   // 时序逻辑：在主时钟 clk 上锁存输入数据 i\_data

&nbsp;   always @(posedge clk, negedge rstn ) begin

&nbsp;       if(!rstn)

&nbsp;           i\_data\_store <= 0;

&nbsp;       else

&nbsp;           i\_data\_store <= i\_data;

&nbsp;   end



&nbsp;   reg \[7:0] seg\_data\_r; // 当前数码管要显示的 8 位数据 (来自 i\_data\_store)

&nbsp;   

&nbsp;   // 组合逻辑：根据 disp\_mode 和 seg7\_addr 选择数据

&nbsp;   always @(\*) begin

&nbsp;       if(disp\_mode==1'b0)begin // Hex 译码模式 (通常只看 32 位数据，每位 4 bits)

&nbsp;           case(seg7\_addr)

&nbsp;               // 从 i\_data\_store 的低 32 位中提取 4 bits 数据 (高 4 位为 0)

&nbsp;               0 : seg\_data\_r = i\_data\_store\[3:0];

&nbsp;               1 : seg\_data\_r = i\_data\_store\[7:4];

&nbsp;               2 : seg\_data\_r = i\_data\_store\[11:8];

&nbsp;               3 : seg\_data\_r = i\_data\_store\[15:12];

&nbsp;               4 : seg\_data\_r = i\_data\_store\[19:16];

&nbsp;               5 : seg\_data\_r = i\_data\_store\[23:20];

&nbsp;               6 : seg\_data\_r = i\_data\_store\[27:24];

&nbsp;               7 : seg\_data\_r = i\_data\_store\[31:28];

&nbsp;           endcase end

&nbsp;       else begin // 穿透/跑马灯模式 (使用 64 位数据，每位 8 bits)

&nbsp;           case(seg7\_addr)

&nbsp;               // 从 i\_data\_store 的 64 位中提取 8 bits 数据

&nbsp;               0 : seg\_data\_r = i\_data\_store\[7:0];

&nbsp;               1 : seg\_data\_r = i\_data\_store\[15:8];

&nbsp;               2 : seg\_data\_r = i\_data\_store\[23:16];

&nbsp;               3 : seg\_data\_r = i\_data\_store\[31:24];

&nbsp;               4 : seg\_data\_r = i\_data\_store\[39:32];

&nbsp;               5 : seg\_data\_r = i\_data\_store\[47:40];

&nbsp;               6 : seg\_data\_r = i\_data\_store\[55:48];

&nbsp;               7 : seg\_data\_r = i\_data\_store\[63:56];

&nbsp;           endcase end

&nbsp;   end

&nbsp;   

&nbsp;   // --- 5) 7段码译码或直接输出 ---

&nbsp;   reg \[7:0] o\_seg\_r; // 段选信号的寄存器版本

&nbsp;   

&nbsp;   // 时序逻辑：进行 Hex 译码并寄存器化输出

&nbsp;   always @(posedge clk, negedge rstn) begin

&nbsp;       if(!rstn)

&nbsp;           o\_seg\_r <= 8'hff; // 复位时全灭

&nbsp;       else if(disp\_mode==1'b0)begin // Hex 译码模式

&nbsp;           // 将 seg\_data\_r 的低 4 位（0-F）译码成 7 段码

&nbsp;           case(seg\_data\_r\[3:0]) // 注意这里使用了 seg\_data\_r\[3:0]

&nbsp;               4'h0 : o\_seg\_r <= 8'hC0;

&nbsp;               4'h1 : o\_seg\_r <= 8'hF9;

&nbsp;               4'h2 : o\_seg\_r <= 8'hA4;

&nbsp;               4'h3 : o\_seg\_r <= 8'hB0;

&nbsp;               4'h4 : o\_seg\_r <= 8'h99;

&nbsp;               4'h5 : o\_seg\_r <= 8'h92;

&nbsp;               4'h6 : o\_seg\_r <= 8'h82;

&nbsp;               4'h7 : o\_seg\_r <= 8'hF8;

&nbsp;               4'h8 : o\_seg\_r <= 8'h80;

&nbsp;               4'h9 : o\_seg\_r <= 8'h90;

&nbsp;               4'hA : o\_seg\_r <= 8'h88;

&nbsp;               4'hB : o\_seg\_r <= 8'h83;

&nbsp;               4'hC : o\_seg\_r <= 8'hC6;

&nbsp;               4'hD : o\_seg\_r <= 8'hA1;

&nbsp;               4'hE : o\_seg\_r <= 8'h86;

&nbsp;               4'hF : o\_seg\_r <= 8'h8E;

&nbsp;               default :o\_seg\_r<=8'hFF; 

&nbsp;           endcase end

&nbsp;       else begin 

&nbsp;          

&nbsp;           o\_seg\_r<=seg\_data\_r;

&nbsp;       end

&nbsp;   end

&nbsp;  

&nbsp;   assign o\_sel = o\_sel\_r;

&nbsp;   assign o\_seg = o\_seg\_r;



endmodule



