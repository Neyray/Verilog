实验任务1，2
目的：设计一个电路，将拨码开关输入的4位二进制数与预设的4位二进制数（1010）进行比较，正确将点亮一位第15号led灯或逐个点亮第#15—>#0号led灯。通过编制这个最简单的游戏电路，让学生逐步熟悉和掌握Vivado的工程建立、Verilog的常用建模方法、Vivado功能仿真和NEXYS4_100t电路板调试过程。最终可以独立编制和调试一个简单的硬件电路。

测试文件：
`timescale 1ns / 1ps

module test_tb();

    reg clk, rstn;
    reg [15:0] sw_i;
    wire [15:0] led_o;
    integer foutput, counter;
    
    // 实例化待测模块
    compare_game u_test(
        .clk(clk),
        .rstn(rstn),
        .CPU_RESETN(rstn),
        .BTNC(1'b0),
        .BTNU(1'b0),
        .BTNL(1'b0),
        .BTNR(1'b0),
        .BTND(1'b0),
        .sw_i(sw_i),
        .led_o(led_o),
        .disp_seg_o(),
        .disp_an_o()
    );
    
    // 初始化
    initial begin
        counter = 0;
        clk = 0;      // 从0开始
        rstn = 0;     // 开始复位
        sw_i = 16'h000A;  // 输入1010（十六进制A）
        foutput = $fopen("results.txt");
        
        // 复位20ns
        #20;
        rstn = 1;     // 释放复位
        
        $display("Start testing...");
    end
    
    // 时钟生成：每5ns翻转一次，周期=10ns
    always #5 clk = ~clk;
    
    // 监控
    always @(posedge clk) begin
        $fdisplay(foutput, "led_o:\t %b", led_o);
        $display("led_o:\t %b", led_o);
        $display("counter: %h", counter);
        counter = counter + 1;
        
        if (counter > 100) begin
            $fclose(foutput);
            $stop;
        end
    end

endmodule

实现文件：
module compare_game(
    input clk,
    input rstn,
    input CPU_RESETN,
    input BTNC,
    input BTNU,
    input BTNL,
    input BTNR,
    input BTND,
    input [15:0] sw_i,
    output reg [15:0] led_o,
    output [7:0] disp_seg_o,
    output [7:0] disp_an_o
);

    // 目标数字
    parameter TARGET = 4'b1010;
    
    // 比较结果
    wire match;
    assign match = (sw_i[3:0] == TARGET);
    
    // 流水灯控制
    reg [3:0] led_cnt;
    reg [24:0] div_cnt;
    
    // 分频器产生tick信号
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            div_cnt <= 25'd0;
        end else begin
            if (div_cnt >= 25'd1_000_000)  // 仿真时用较小值
                div_cnt <= 25'd0;
            else
                div_cnt <= div_cnt + 1'b1;
        end
    end
    
    wire tick = (div_cnt == 25'd1_000_000);
    
    // LED控制逻辑
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            led_o <= 16'b0000_0000_0000_0000;
            led_cnt <= 4'd0;
        end else begin
            if (match) begin
                // 匹配成功：只点亮led_o[15]
                led_o <= 16'b1000_0000_0000_0000;
                led_cnt <= 4'd0;
            end else begin
                // 不匹配：流水灯效果
                if (tick) begin
                    if (led_cnt <= 4'd15) begin
                        led_o[15 - led_cnt] <= 1'b1;
                        led_cnt <= led_cnt + 1'b1;
                    end else begin
                        // 重新开始
                        led_o <= 16'b0000_0000_0000_0000;
                        led_cnt <= 4'd0;
                    end
                end
            end
        end
    end
    
    // 数码管关闭
    assign disp_seg_o = 8'b11111111;
    assign disp_an_o = 8'b11111111;

endmodule


实验任务3
新建一个工程seg7_top,并新建一个seg7_top.v顶层模块，在seg7_top.v模块中，例化上述seg7x16.v模块程序，并传送一组数值31’b0111_0110_0101_0100_0011_0010_0001_0000给该子模块，下板在数码管上显示给定的8个16进制数字。

seg7x16:
module seg7x16(
    input clk,          // 系统主时钟 (通常为 50MHz 或 100MHz)
    input rstn,         // 异步低电平复位信号 (低电平有效)
    input disp_mode,    // 显示模式选择信号 (0: 译码模式, 1: 穿透模式/直接显示)
    input [63:0] i_data, // 待显示的 64 位数据 (8 个 8 位数码管数据)
    output [7:0] o_seg, // 7段数码管的段选线输出 (a, b, c, d, e, f, g, dp)
    output [7:0] o_sel  // 8位共阴/共阳数码管的位选线输出 (激活哪个数码管)
    );

    // --- 1) 扫描时钟分频 ---
    reg [14:0] cnt;    // 分频计数器
    wire seg7_clk;     // 数码管扫描时钟 (低频，通常几百 Hz 到几 kHz)
    
    // 时序逻辑：分频计数
    always @(posedge clk, negedge rstn) begin
        if (!rstn)
            cnt <= 0;
        else
            cnt <= cnt + 1'b1;
    end
    
    // 输出扫描时钟：使用计数器的第 14 位，实现 clk / 2^15 的分频
    assign seg7_clk = cnt[14]; 

    // --- 2) 数码管位选地址生成 (8选1) ---
    reg [2:0] seg7_addr; // 当前被选中的数码管地址 (0 到 7)
    
    // 时序逻辑：在扫描时钟 seg7_clk 的上升沿递增地址
    always @(posedge seg7_clk, negedge rstn) begin
        if(!rstn)
            seg7_addr <= 0;
        else
            seg7_addr <= seg7_addr + 1'b1;
    end
      
    // --- 3) 位选信号生成 (o_sel) ---
    reg [7:0] o_sel_r; // 位选信号的寄存器版本
    
    // 组合逻辑：根据当前地址 seg7_addr 确定哪个数码管被使能 (一位有效)
    always @(*) begin
        case (seg7_addr)
            7 : o_sel_r = 8'b01111111; // 选中第 7 位 (最高位)
            6 : o_sel_r = 8'b10111111;
            5 : o_sel_r = 8'b11011111;
            4 : o_sel_r = 8'b11101111;
            3 : o_sel_r = 8'b11110111;
            2 : o_sel_r = 8'b11111011;
            1 : o_sel_r = 8'b11111101;
            0 : o_sel_r = 8'b11111110; // 选中第 0 位 (最低位)
        endcase
    end
    
    // --- 4) 数据选择逻辑 (根据地址选择当前数码管的数据) ---
    reg [63:0] i_data_store; // 将输入数据 i_data 寄存器化存储
    
    // 时序逻辑：在主时钟 clk 上锁存输入数据 i_data
    always @(posedge clk, negedge rstn ) begin
        if(!rstn)
            i_data_store <= 0;
        else
            i_data_store <= i_data;
    end

    reg [7:0] seg_data_r; // 当前数码管要显示的 8 位数据 (来自 i_data_store)
    
    // 组合逻辑：根据 disp_mode 和 seg7_addr 选择数据
    always @(*) begin
        if(disp_mode==1'b0)begin // Hex 译码模式 (通常只看 32 位数据，每位 4 bits)
            case(seg7_addr)
                // 从 i_data_store 的低 32 位中提取 4 bits 数据 (高 4 位为 0)
                0 : seg_data_r = i_data_store[3:0];
                1 : seg_data_r = i_data_store[7:4];
                2 : seg_data_r = i_data_store[11:8];
                3 : seg_data_r = i_data_store[15:12];
                4 : seg_data_r = i_data_store[19:16];
                5 : seg_data_r = i_data_store[23:20];
                6 : seg_data_r = i_data_store[27:24];
                7 : seg_data_r = i_data_store[31:28];
            endcase end
        else begin // 穿透/跑马灯模式 (使用 64 位数据，每位 8 bits)
            case(seg7_addr)
                // 从 i_data_store 的 64 位中提取 8 bits 数据
                0 : seg_data_r = i_data_store[7:0];
                1 : seg_data_r = i_data_store[15:8];
                2 : seg_data_r = i_data_store[23:16];
                3 : seg_data_r = i_data_store[31:24];
                4 : seg_data_r = i_data_store[39:32];
                5 : seg_data_r = i_data_store[47:40];
                6 : seg_data_r = i_data_store[55:48];
                7 : seg_data_r = i_data_store[63:56];
            endcase end
    end
    
    // --- 5) 7段码译码或直接输出 ---
    reg [7:0] o_seg_r; // 段选信号的寄存器版本
    
    // 时序逻辑：进行 Hex 译码并寄存器化输出
    always @(posedge clk, negedge rstn) begin
        if(!rstn)
            o_seg_r <= 8'hff; // 复位时全灭
        else if(disp_mode==1'b0)begin // Hex 译码模式
            // 将 seg_data_r 的低 4 位（0-F）译码成 7 段码
            case(seg_data_r[3:0]) // 注意这里使用了 seg_data_r[3:0]
                4'h0 : o_seg_r <= 8'hC0;
                4'h1 : o_seg_r <= 8'hF9;
                4'h2 : o_seg_r <= 8'hA4;
                4'h3 : o_seg_r <= 8'hB0;
                4'h4 : o_seg_r <= 8'h99;
                4'h5 : o_seg_r <= 8'h92;
                4'h6 : o_seg_r <= 8'h82;
                4'h7 : o_seg_r <= 8'hF8;
                4'h8 : o_seg_r <= 8'h80;
                4'h9 : o_seg_r <= 8'h90;
                4'hA : o_seg_r <= 8'h88;
                4'hB : o_seg_r <= 8'h83;
                4'hC : o_seg_r <= 8'hC6;
                4'hD : o_seg_r <= 8'hA1;
                4'hE : o_seg_r <= 8'h86;
                4'hF : o_seg_r <= 8'h8E;
                default :o_seg_r<=8'hFF; 
            endcase end
        else begin 
           
            o_seg_r<=seg_data_r;
        end
    end
   
    assign o_sel = o_sel_r;
    assign o_seg = o_seg_r;

endmodule




display文件：
module work3(clk,rstn,sw_i,disp_seg_o,disp_an_o);
    input clk;
    input rstn;
    input[15:0]sw_i;
    output[7:0]disp_an_o,disp_seg_o;
    

reg [31:0] clkdiv;
wire Clk_CPU;

always@(posedge clk or negedge rstn) begin
    if(!rstn)
       clkdiv<=0;
    else clkdiv<=clkdiv+1'b1;
    end
assign Clk_CPU=(sw_i[15])?clkdiv[27]:clkdiv[25];

reg [63:0]display_data;
reg [5:0]led_data_addr;
reg [63:0]led_disp_data;
parameter LED_DATA_NUM = 19;

reg [63:0]LED_DATA[18:0];
 initial begin
    LED_DATA[0]=64'hC6F6F6F0C6F6F6F0;
    LED_DATA[1] =64'hF9F6F6CFF9F6F6CF;
    LED_DATA[2]=64'hFFC6F0FFFFC6F0FF;
    LED_DATA[3]=64'hFFC0FFFFFFC0FFFF;
    LED_DATA[4]=64'hFFA3FFFFFFA3FFFF;
    LED_DATA[5]=64'hFFFFA3FFFFFFA3FF;
    LED_DATA[6]=64'hFFFF9CFFFFFF9CFF;
    LED_DATA[7]=64'hFF9EBCFFFF9EBCFF;
    LED_DATA[8]=64'hFF9CFFFFFF9CFFFF;
    LED_DATA[9]=64'hFFC0FFFFFFC0FFFF;
    LED_DATA[10]=64'hFFA3FFFFFFA3FFFF;
    LED_DATA[11]=64'hFFA7B3FFFFA7B3FF;
    LED_DATA[12]=64'hFFC6F0FFFFC6F0FF;
    LED_DATA[13]=64'hF9F6F6CFF9F6F6CF;
    LED_DATA[14]=64'h9EBEBEBC9EBEBEBC;
    LED_DATA[15]=64'h2737373327373733;
    LED_DATA[16]=64'h505454EC505454EC;
    LED_DATA[17]=64'h744454F8744454F8;
    LED_DATA[18]=64'h0062080000620800;
 end
 
always@(posedge Clk_CPU or negedge rstn) begin
    if(!rstn) begin led_data_addr = 6'd0 ;led_disp_data = 64'b1;end
    else if(sw_i[0]==1'b1) begin
        if (led_data_addr == LED_DATA_NUM) begin led_data_addr =6'd0;led_disp_data = 64'b1;end
        led_disp_data = LED_DATA[led_data_addr];
        led_data_addr = led_data_addr + 1'b1; end
      else  led_data_addr = led_data_addr ;
end

wire [31:0]instr;
reg[31:0]reg_data;
reg[31:0]alu_disp_data;
reg[31:0]dmem_data;

always @(sw_i) begin
    if (sw_i[0]==0) begin
    case (sw_i[14:11])
        4'b1000:display_data =instr;
        4'b0100:display_data = reg_data;
        4'b0010:display_data = alu_disp_data;
        4'b0001:display_data= dmem_data;
        default: display_data=instr;
    endcase end
else begin display_data = led_disp_data;end
end


seg7x16 u_seg7x16(
.clk(clk),
.rstn (rstn),
.i_data(display_data),
.disp_mode(sw_i[0]),
.o_seg(disp_seg_o),
.o_sel(disp_an_o)
);

endmodule

实验任务4---ROM模块
rom就是你定义一个虚拟模块，vivado自动帮你生成它的模块内部代码，然后你只需要导入一个数据文件进去，就可以直接使用这个虚拟模块读取，然后你在外面套那个数码管的代码，把跑马灯的那些数据换成从虚拟模块读取，就能显示rom内容了

seg7x16文件：
//`timescale 1ns / 1ps
module seg7x16(
    input clk,
    input rstn,
    input [31:0] i_data,
    output [7:0] o_seg,
    output [7:0] o_sel
);

    // 1) 分频 - 利用计数器cnt对clk分频得到seg7_clk
    reg [14:0] cnt;
    wire seg7_clk;
    
    always @(posedge clk, negedge rstn)
        if (!rstn)
            cnt <= 0;
        else
            cnt <= cnt + 1'b1;
    
    assign seg7_clk = cnt[14];

    // 2) 8选1 - seg7_addr作为8选1选择器的地址信号
    reg [2:0] seg7_addr;
    
    always @(posedge seg7_clk, negedge rstn)
        if (!rstn)
            seg7_addr <= 0;
        else
            seg7_addr <= seg7_addr + 1'b1;

    // 3) 输出选中数码管使能信号
    reg [7:0] o_sel_r;
    
    always @(*) 
        case(seg7_addr)
            3'd7: o_sel_r = 8'b01111111;
            3'd6: o_sel_r = 8'b10111111;
            3'd5: o_sel_r = 8'b11011111;
            3'd4: o_sel_r = 8'b11101111;
            3'd3: o_sel_r = 8'b11110111;
            3'd2: o_sel_r = 8'b11111011;
            3'd1: o_sel_r = 8'b11111101;
            3'd0: o_sel_r = 8'b11111110;
        endcase

    // 4) 8个数码管显示数字串 - 存储输入数据
    reg [31:0] i_data_store;
    
    always @(posedge clk, negedge rstn)
        if (!rstn)
            i_data_store <= 0;
        else
            i_data_store <= i_data;

    // 当前一个数码管要显示的数串
    reg [3:0] seg_data_r;
    
    always @(*)
        case(seg7_addr)
            3'd0: seg_data_r = i_data_store[3:0];
            3'd1: seg_data_r = i_data_store[7:4];
            3'd2: seg_data_r = i_data_store[11:8];
            3'd3: seg_data_r = i_data_store[15:12];
            3'd4: seg_data_r = i_data_store[19:16];
            3'd5: seg_data_r = i_data_store[23:20];
            3'd6: seg_data_r = i_data_store[27:24];
            3'd7: seg_data_r = i_data_store[31:28];
        endcase

    // 5) 要显示数字的7段码
    reg [7:0] o_seg_r;
    
    always @(posedge clk, negedge rstn)
        if (!rstn)
            o_seg_r <= 8'hff;
        else
            case(seg_data_r)
                4'h0: o_seg_r <= 8'hC0;
                4'h1: o_seg_r <= 8'hF9;
                4'h2: o_seg_r <= 8'hA4;
                4'h3: o_seg_r <= 8'hB0;
                4'h4: o_seg_r <= 8'h99;
                4'h5: o_seg_r <= 8'h92;
                4'h6: o_seg_r <= 8'h82;
                4'h7: o_seg_r <= 8'hF8;
                4'h8: o_seg_r <= 8'h80;
                4'h9: o_seg_r <= 8'h90;
                4'hA: o_seg_r <= 8'h88;
                4'hB: o_seg_r <= 8'h83;
                4'hC: o_seg_r <= 8'hC6;
                4'hD: o_seg_r <= 8'hA1;
                4'hE: o_seg_r <= 8'h86;
                4'hF: o_seg_r <= 8'h8E;
            endcase

    assign o_sel = o_sel_r;
    assign o_seg = o_seg_r;

endmodule

sccomp文件：

module sccomp(clk, rstn, sw_i, disp_seg_o, disp_an_o);
    input clk;
    input rstn;
    input [15:0] sw_i;
    output [7:0] disp_an_o, disp_seg_o;
    
    reg [31:0] clkdiv;
    wire clk_CPU;
    
    // 时钟分频
    always @(posedge clk or negedge rstn) begin
        if (!rstn) 
            clkdiv <= 0;
        else 
            clkdiv <= clkdiv + 1'b1;
    end
    
    assign clk_CPU = (sw_i[15]) ? clkdiv[27] : clkdiv[25];
    
    // 7段数码管显示相关
    reg [63:0] display_data;
    reg [5:0] led_data_addr;
    reg [63:0] led_disp_data;
    wire [63:0] rom_data_out;
    
    parameter LED_DATA_NUM = 19;
    
    // ROM IP核实例化 - 方案1: 纯组合逻辑ROM
    dist_mem_gen_0 u_led_rom (
        .a(led_data_addr[4:0]),     // 地址输入，5位(0-18)
        .spo(rom_data_out)           // 数据输出 64位
    );
    
    // 产生LED_DATA地址和数据
    always @(posedge clk_CPU or negedge rstn) begin
        if (!rstn) begin
            led_data_addr <= 6'd0;
            led_disp_data <= 64'b1;
        end
        else if (sw_i[0] == 1'b1) begin
            if (led_data_addr == LED_DATA_NUM) begin
                led_data_addr <= 6'd0;
            end
            else begin
                led_data_addr <= led_data_addr + 1'b1;
            end
            led_disp_data <= rom_data_out;
        end
        else begin
            led_data_addr <= led_data_addr;
            led_disp_data <= led_disp_data;
        end
    end
    
    // 其他信号声明
    wire [31:0] instr;
    reg [31:0] reg_data;
    reg [31:0] alu_disp_data;
    reg [31:0] demem_data;
    
    // 为未使用的信号赋默认值
    assign instr = 32'h00000000;
    
    always @(posedge clk_CPU or negedge rstn) begin
        if (!rstn) begin
            reg_data <= 32'h0;
            alu_disp_data <= 32'h0;
            demem_data <= 32'h0;
        end
        else begin
            reg_data <= 32'h0;
            alu_disp_data <= 32'h0;
            demem_data <= 32'h0;
        end
    end
    
    // 选择显示源数据
    always @(*) begin
        if (sw_i[0] == 0) begin
            case (sw_i[14:11])
                4'b1000: display_data = {32'h0, instr};
                4'b0100: display_data = {32'h0, reg_data};
                4'b0010: display_data = {32'h0, alu_disp_data};
                4'b0001: display_data = {32'h0, demem_data};
                default: display_data = {32'h0, instr};
            endcase
        end
        else begin
            display_data = led_disp_data;
        end
    end
    
    // 7段数码管显示模块实例化
    seg7x16 u_seg7x16(
        .clk(clk),
        .rstn(rstn),
        .i_data(display_data[31:0]),
        .o_seg(disp_seg_o),
        .o_sel(disp_an_o)
    );

endmodule

实验任务5---RF与ALU连接的实验
实验目的：
1、使用verilog语言设计并实现一个RegisterFile。它由32×32位的寄存器堆（即含有32个寄存器，每个寄存器32位，其中#0寄存器永远为零。
2、初步了解使用Fpga实现RF设计的全过程，熟识vivado软件基本功能的使用。

原理概念：寄存器文件（register file）又称寄存器堆，是 CPU 中多个寄存器组成的阵列，通常由快速的静态随机读写存储器（SRAM）实现。这种 RAM 具有专门的读端口与写端口，可以多路并发访问不同的寄存器。

实验目的： 
1.根据ALU原理框图，使用verilog语言设计并实现一个32位的ALU模块，运算指令码长度[4:0]；
2.一个32位数输入到A口，或由sw10-sw7输入4位数到A口；
3.一个32位数输入到B口，或由SW6-SW3输入4位数到B口
4.运算器暂只支持”加、减 “2种操作，输入控制信号ALUOp（[4:0]）；
5.结果输出到C[31:0]；
由sw[12]控制数码管显示A，B，C，Zero四个数。

实验任务二：  
1）实现RF部件和ALU部件的关联，使得指定寄存器的数值送入ALU部件参与运算，具体参见下图：
2）通过SW_i输入双端口要读出的寄存器编号A1，A2，并将读出的数值RD1，RD2送入ALU的A，B输入端，根据设定的ALUOp，计算结果，并显示。
3）通过SW_i输入要写入寄存器编号和数值A3，WD，再通过步骤2），将计算结果显示出来。


RF_ALU_top：


//=====================================================
// ALU Module Definition
//=====================================================
`define ALUOp_add 5'b00001
`define ALUOp_sub 5'b00010

module alu(
    input signed [31:0] A, B,      // ALU input numbers
    input [4:0] ALUOp,              // ALU operation code
    output signed [31:0] C,         // ALU result
    output reg [7:0] Zero           // Zero flag
);
    reg signed [31:0] C_r;
    
    always @(*) begin
        case(ALUOp)
            `ALUOp_add: C_r = A + B;
            `ALUOp_sub: C_r = A - B;
            default: C_r = 32'h0;
        endcase
        
        // Zero flag: Zero[0] indicates if result is zero
        if(C_r == 32'h0)
            Zero = 8'h01;
        else
            Zero = 8'h00;
    end
    
    assign C = C_r;
endmodule

//=====================================================
// Register File Module Definition  
//=====================================================
module RF(
    input clk,                      // 100MHz clock
    input rst,                      // Reset signal
    input RFWr,                     // Register write enable
    input [15:0] sw_i,              // Switch input
    input [4:0] A1, A2, A3,         // Register numbers
    input [31:0] WD,                // Write data
    output reg [31:0] RD1, RD2      // Read data outputs
);
    reg [31:0] rf[31:0];            // 32 registers, each 32 bits
    integer i;
    
    // Initialize registers
    initial begin
        for(i = 0; i < 32; i = i + 1)
            rf[i] = i;              // Initialize rf[i] = i
    end
    
    // Write operation
    always @(posedge clk or posedge rst) begin
        if(rst) begin
            for(i = 0; i < 32; i = i + 1)
                rf[i] <= i;
        end
        else begin
            if(RFWr && sw_i[1] == 0 && A3 != 0) begin  // sw[1]=0: normal mode, can modify
                rf[A3] <= WD;
            end
        end
        rf[0] <= 32'h0;  // rf[0] always 0
    end
    
    // Read operation (combinational)
    always @(*) begin
        RD1 = rf[A1];
        RD2 = rf[A2];
    end
endmodule

//=====================================================
// Top Module - RF and ALU Integration
//=====================================================
module top(
    input clk,
    input rstn,
    input [15:0] sw_i,
    input CPU_RESETN,
    input BTNC, BTNU, BTNL, BTNR, BTND,
    output [7:0] disp_seg_o,
    output [7:0] disp_an_o,
    output [15:0] led_o
);
    // Clock divider for display
    reg [31:0] clkdiv;
    wire Clk_CPU;
    
    always @(posedge clk or negedge rstn) begin
        if(!rstn)
            clkdiv <= 0;
        else
            clkdiv <= clkdiv + 1'b1;
    end
    
    assign Clk_CPU = (sw_i[15]) ? clkdiv[27] : clkdiv[25];
    
    //=================================================
    // Signal Definitions
    //=================================================
    wire [4:0] A1, A2, A3;
    wire [31:0] WD;
    wire [31:0] RD1, RD2;
    wire RFWr;
    wire [4:0] ALUOp;
    wire [31:0] A_alu, B_alu;
    wire signed [31:0] C_alu;
    wire [7:0] Zero;
    
    //=================================================
    // Input Signal Processing
    //=================================================
    // sw[2]=0: Read mode
    //   sw[10:8] -> A1 (read register 1)
    //   sw[7:5]  -> A2 (read register 2)
    // sw[2]=1: Write mode
    //   sw[10:8] -> A3 (write register number)
    //   sw[7:5]  -> WD (write data, sign-extended)
    
    assign RFWr = sw_i[2];  // sw[2]=1: write enable
    
    // A1, A2, A3 address assignment (extend 3 bits to 5 bits)
    assign A1 = (sw_i[2] == 0) ? {2'b00, sw_i[10:8]} : 5'b0;
    assign A2 = (sw_i[2] == 0) ? {2'b00, sw_i[7:5]} : 5'b0;
    assign A3 = (sw_i[2] == 1) ? {2'b00, sw_i[10:8]} : 5'b0;
    
    // Write data - sign extend 3 bits to 32 bits
    assign WD = (sw_i[2] == 1) ? {{29{sw_i[7]}}, sw_i[7:5]} : 32'h0;
    
    // ALU operation control
    // sw[4:3] -> ALUOp
    // For simplicity: sw[3]=0 -> sub, sw[3]=1 -> add
    assign ALUOp = (sw_i[3] == 1) ? `ALUOp_add : `ALUOp_sub;
    
    //=================================================
    // Module Instantiation
    //=================================================
    // Register File
    RF u_rf(
        .clk(clk),
        .rst(~rstn),
        .RFWr(RFWr),
        .sw_i(sw_i),
        .A1(A1),
        .A2(A2),
        .A3(A3),
        .WD(WD),
        .RD1(RD1),
        .RD2(RD2)
    );
    
    // ALU inputs come from RF outputs
    assign A_alu = RD1;
    assign B_alu = RD2;
    
    // ALU
    alu u_alu(
        .A(A_alu),
        .B(B_alu),
        .ALUOp(ALUOp),
        .C(C_alu),
        .Zero(Zero)
    );
    
    //=================================================
    // Display Control Logic
    //=================================================
    reg [63:0] display_data;
    reg [5:0] disp_addr;
    reg [63:0] disp_data_buf[34:0];  // Buffer for cyclic display
    
    // Prepare display data based on mode
    always @(posedge Clk_CPU or negedge rstn) begin
        if(!rstn) begin
            disp_addr <= 6'd0;
        end
        else if(sw_i[14] == 1'b1) begin  // sw[14]=1: Display RF contents
            if(disp_addr >= 6'd33)  // 32 registers + 1 FFFFFFFF + reset
                disp_addr <= 6'd0;
            else
                disp_addr <= disp_addr + 1'b1;
        end
        else if(sw_i[12] == 1'b1) begin  // sw[12]=1: Display A,B,C,Zero
            if(disp_addr >= 6'd5)  // 4 values + 1 FFFFFFFF + reset
                disp_addr <= 6'd0;
            else
                disp_addr <= disp_addr + 1'b1;
        end
        else begin
            disp_addr <= 6'd0;
        end
    end
    
    // Display data selection
    always @(*) begin
        if(sw_i[14] == 1'b1) begin  // Display RF contents
            if(disp_addr < 32)
                display_data = u_rf.rf[disp_addr];
            else
                display_data = 64'hFFFFFFFFFFFFFFFF;
        end
        else if(sw_i[12] == 1'b1) begin  // Display A, B, C, Zero
            case(disp_addr)
                6'd0: display_data = {32'h0, A_alu};      // A
                6'd1: display_data = {32'h0, B_alu};      // B
                6'd2: display_data = {32'h0, C_alu};      // C
                6'd3: display_data = {56'h0, Zero};       // Zero
                default: display_data = 64'hFFFFFFFFFFFFFFFF;
            endcase
        end
        else begin
            display_data = {32'h0, C_alu};  // Default: display ALU result
        end
    end
    
    // LED display - show ALU result on lower 16 LEDs
    assign led_o = C_alu[15:0];
    
    //=================================================
    // 7-Segment Display Module
    //=================================================
    seg7x16 u_seg7x16(
        .clk(clk),
        .rstn(rstn),
        .i_data(display_data),
        .disp_mode(1'b0),  // Hex decode mode
        .o_seg(disp_seg_o),
        .o_sel(disp_an_o)
    );

endmodule

seg7x16:


module seg7x16(
    input clk,          // 系统主时钟 (通常为 50MHz 或 100MHz)
    input rstn,         // 异步低电平复位信号 (低电平有效)
    input disp_mode,    // 显示模式选择信号 (0: 译码模式, 1: 穿透模式/直接显示)
    input [63:0] i_data, // 待显示的 64 位数据 (8 个 8 位数码管数据)
    output [7:0] o_seg, // 7段数码管的段选线输出 (a, b, c, d, e, f, g, dp)
    output [7:0] o_sel  // 8位共阴/共阳数码管的位选线输出 (激活哪个数码管)
    );

    // --- 1) 扫描时钟分频 ---
    reg [14:0] cnt;    // 分频计数器
    wire seg7_clk;     // 数码管扫描时钟 (低频，通常几百 Hz 到几 kHz)
    
    // 时序逻辑：分频计数
    always @(posedge clk, negedge rstn) begin
        if (!rstn)
            cnt <= 0;
        else
            cnt <= cnt + 1'b1;
    end
    
    // 输出扫描时钟：使用计数器的第 14 位，实现 clk / 2^15 的分频
    assign seg7_clk = cnt[14]; 

    // --- 2) 数码管位选地址生成 (8选1) ---
    reg [2:0] seg7_addr; // 当前被选中的数码管地址 (0 到 7)
    
    // 时序逻辑：在扫描时钟 seg7_clk 的上升沿递增地址
    always @(posedge seg7_clk, negedge rstn) begin
        if(!rstn)
            seg7_addr <= 0;
        else
            seg7_addr <= seg7_addr + 1'b1;
    end
      
    // --- 3) 位选信号生成 (o_sel) ---
    reg [7:0] o_sel_r; // 位选信号的寄存器版本
    
    // 组合逻辑：根据当前地址 seg7_addr 确定哪个数码管被使能 (一位有效)
    always @(*) begin
        case (seg7_addr)
            7 : o_sel_r = 8'b01111111; // 选中第 7 位 (最高位)
            6 : o_sel_r = 8'b10111111;
            5 : o_sel_r = 8'b11011111;
            4 : o_sel_r = 8'b11101111;
            3 : o_sel_r = 8'b11110111;
            2 : o_sel_r = 8'b11111011;
            1 : o_sel_r = 8'b11111101;
            0 : o_sel_r = 8'b11111110; // 选中第 0 位 (最低位)
        endcase
    end
    
    // --- 4) 数据选择逻辑 (根据地址选择当前数码管的数据) ---
    reg [63:0] i_data_store; // 将输入数据 i_data 寄存器化存储
    
    // 时序逻辑：在主时钟 clk 上锁存输入数据 i_data
    always @(posedge clk, negedge rstn ) begin
        if(!rstn)
            i_data_store <= 0;
        else
            i_data_store <= i_data;
    end

    reg [7:0] seg_data_r; // 当前数码管要显示的 8 位数据 (来自 i_data_store)
    
    // 组合逻辑：根据 disp_mode 和 seg7_addr 选择数据
    always @(*) begin
        if(disp_mode==1'b0)begin // Hex 译码模式 (通常只看 32 位数据，每位 4 bits)
            case(seg7_addr)
                // 从 i_data_store 的低 32 位中提取 4 bits 数据 (高 4 位为 0)
                0 : seg_data_r = i_data_store[3:0];
                1 : seg_data_r = i_data_store[7:4];
                2 : seg_data_r = i_data_store[11:8];
                3 : seg_data_r = i_data_store[15:12];
                4 : seg_data_r = i_data_store[19:16];
                5 : seg_data_r = i_data_store[23:20];
                6 : seg_data_r = i_data_store[27:24];
                7 : seg_data_r = i_data_store[31:28];
            endcase end
        else begin // 穿透/跑马灯模式 (使用 64 位数据，每位 8 bits)
            case(seg7_addr)
                // 从 i_data_store 的 64 位中提取 8 bits 数据
                0 : seg_data_r = i_data_store[7:0];
                1 : seg_data_r = i_data_store[15:8];
                2 : seg_data_r = i_data_store[23:16];
                3 : seg_data_r = i_data_store[31:24];
                4 : seg_data_r = i_data_store[39:32];
                5 : seg_data_r = i_data_store[47:40];
                6 : seg_data_r = i_data_store[55:48];
                7 : seg_data_r = i_data_store[63:56];
            endcase end
    end
    
    // --- 5) 7段码译码或直接输出 ---
    reg [7:0] o_seg_r; // 段选信号的寄存器版本
    
    // 时序逻辑：进行 Hex 译码并寄存器化输出
    always @(posedge clk, negedge rstn) begin
        if(!rstn)
            o_seg_r <= 8'hff; // 复位时全灭
        else if(disp_mode==1'b0)begin // Hex 译码模式
            // 将 seg_data_r 的低 4 位（0-F）译码成 7 段码
            case(seg_data_r[3:0]) // 注意这里使用了 seg_data_r[3:0]
                4'h0 : o_seg_r <= 8'hC0;
                4'h1 : o_seg_r <= 8'hF9;
                4'h2 : o_seg_r <= 8'hA4;
                4'h3 : o_seg_r <= 8'hB0;
                4'h4 : o_seg_r <= 8'h99;
                4'h5 : o_seg_r <= 8'h92;
                4'h6 : o_seg_r <= 8'h82;
                4'h7 : o_seg_r <= 8'hF8;
                4'h8 : o_seg_r <= 8'h80;
                4'h9 : o_seg_r <= 8'h90;
                4'hA : o_seg_r <= 8'h88;
                4'hB : o_seg_r <= 8'h83;
                4'hC : o_seg_r <= 8'hC6;
                4'hD : o_seg_r <= 8'hA1;
                4'hE : o_seg_r <= 8'h86;
                4'hF : o_seg_r <= 8'h8E;
                default :o_seg_r<=8'hFF; 
            endcase end
        else begin 
           
            o_seg_r<=seg_data_r;
        end
    end
   
    assign o_sel = o_sel_r;
    assign o_seg = o_seg_r;

endmodule
